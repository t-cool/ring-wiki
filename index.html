
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Ring Wiki</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="./assets/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="ring-wiki"
                  title="Ring Wiki"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="はじめに" duration="0">
        <p>Ring は、プログラミング言語 <a href="http://clojure.org/" target="_blank">Clojure</a> で Web アプリケーションを構築するための低レベルのライブラリです。Ruby の <a href="http://rack.github.io/" target="_blank">Rack</a> や Python の <a href="http://wsgi.readthedocs.org/" target="_blank">WSGI</a>、あるいは Java の Servlet の仕様に似ています。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ringを使う理由" duration="0">
        <p>Web アプリケーションの基盤として Ring を使うと、以下のメリットがあります。</p>
<ul>
<li>Clojure の関数やマップを使ってアプリケーションを書くことができる</li>
<li>自動リロードされる開発サーバでアプリケーションを実行できる</li>
<li>アプリケーションを Java サーブレットにコンパイルすることができる</li>
<li>アプリケーションを Java war ファイルとしてパッケージ化できる</li>
<li>あらかじめ用意されている豊富なミドルウェアを利用できる</li>
<li>作成したアプリケーションを <a href="http://aws.amazon.com/elasticbeanstalk/" target="_blank">Amazon Elastic Beanstalk</a> や <a href="http://heroku.com/" target="_blank">Heroku</a> などのクラウド環境にアプリケーションをデプロイできる</li>
</ul>
<p>Clojure で Web アプリケーションを書く場合、Ring は業界の標準として認められている基盤です。 <a href="http://compojure.org/" target="_blank">Compojure</a> や <a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a> のような高レベルのフレームワークもありますが、 <a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a> などの高レベルのフレームワークは Ring を共通の基盤として使用しています。</p>
<p>Ring は低レベルのインターフェースしか提供していませんが、高レベルのインターフェースを使用する場合でも Ring の動作を理解しておくと便利です。 Ring の基本的な理解がなければミドルウェアを書くこともできませんし、アプリケーションのデバッグも困難になるでしょう。</p>


      </google-codelab-step>
    
      <google-codelab-step label="コンセプト" duration="0">
        <p>Ring 用に開発された Web アプリケーションは、4 つのコンポーネントで構成されています。</p>
<ul>
<li>ハンドラ (Handler)</li>
<li>リクエスト (Request)</li>
<li>レスポンス (Response)</li>
<li>ミドルウェア (Middleware)</li>
</ul>
<h2 is-upgraded><strong>ハンドラ</strong></h2>
<pre>(defn what-is-my-ip [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body (:remote-addr request)})</pre>
<p>この関数は、Ring が HTTP レスポンスに変換できるマップを返します。このレスポンスは、Web アプリケーションへのアクセスに使用された IP アドレスを含むプレーンテキストファイルを返します。</p>
<p>ハンドラは 非同期 の場合もあります。このタイプのハンドラは 3 つの引数を取ります。 リクエストのマップ、レスポンスのコールバック、例外のコールバックです。</p>
<pre>(defn what-is-my-ip [request respond raise]
  (respond {:status 200
            :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
            :body (:remote-addr request)}))</pre>
<p>この 2 つのタイプのハンドラはそれぞれ異なるアリティを持っているので、これらを組み合わせて、同期または非同期に使用できるハンドラを作ることができます。</p>
<pre>(defn what-is-my-ip
  ([request]
    {:status 200
     :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
     :body (:remote-addr request)})
  ([request respond raise]
    (respond (what-is-my-ip request))))</pre>
<p>公式の Ring ミドルウェアは、両方のタイプのハンドラをサポートしていますが、ほとんどの目的では同期ハンドラで十分です。</p>
<p>ハンドラ関数は、次のセクションで説明するさまざまな方法でウェブアプリケーションに変換することができます。</p>
<h2 is-upgraded><strong>リクエスト</strong></h2>
<p>HTTP リクエストは Clojure のマップで表現されます。常に存在するいくつかの標準的なキーがありますが、リクエストにはミドルウェアによって追加されたカスタムキーが含まれることがあります（しばしばそうなります）。</p>
<p>標準的なキーは次の通りです。</p>
<ul>
<li><code>:server-port</code> リクエストを処理するためのポートです。</li>
<li><code>:server-name</code> 解決されたサーバ名、またはサーバの IP アドレスです。</li>
<li><code>:remote-addr</code> リクエストを送信したクライアントまたは最後のプロキシの IP アドレスです。</li>
<li><code>:uri</code> リクエストの URI (ドメイン名の後のフルパス)です。</li>
<li><code>:query-string</code> クエリ文字列があれば、それを入力します。</li>
<li><code>:scheme</code> トランスポートプロトコルです。<code>:http</code> または <code>:https</code> のいずれかになります。</li>
<li><code>:request-method</code> HTTP リクエストメソッドで、<code>:get</code>, <code>:head</code>, <code>:options</code>, <code>:put</code>, <code>:post</code>, <code>:delete</code> のいずれかになります。</li>
<li><code>:headers</code> (ヘッダー) 小文字のヘッダ名文字列から対応するヘッダ値文字列への Clojure マップです。</li>
<li><code>:body</code> もしあれば、リクエストボディの入力ストリームです。</li>
</ul>
<p>以前のバージョンの Ring では以下のキーがありましたが、これらは現在 DEPRECATED されています。</p>
<ul>
<li><code>:content-type</code> リクエストボディの MIME タイプ（分かっている場合）。</li>
<li><code>:Content-Length</code> もしわかっていれば、リクエストボディのバイト数です。</li>
<li><code>:character-encoding</code> もしわかっていれば、リクエストボディで使用されている文字エンコーディングの名前です。</li>
</ul>
<h2 is-upgraded><strong>レスポンス</strong></h2>
<p>レスポンスマップはハンドラによって作成され、3 つのキーが含まれています。</p>
<ul>
<li><code>:status</code> 200、302、404 などの HTTP ステータスコードです。</li>
<li><code>:headers</code> HTTP ヘッダ名からヘッダ値への Clojure マップです。これらの値は文字列で、その場合は HTTP レスポンスで 1 つの名前/値のヘッダが送信されます。また、文字列の集合体で、その場合は各値に対して名前/値のヘッダが送信されます。</li>
<li><code>:body</code> レスポンスのステータスコードに対してレスポンスボディが適切な場合には、レスポンスボディの表現です。ボディは4つのタイプのうちの1つです。</li>
</ul>
<p><code>・String</code> ボディはクライアントに直接送信されます。</p>
<p><code>・ISeq</code> seqの各要素は、文字列としてクライアントに送信されます。</p>
<p><code>・File</code> 参照されるファイルの内容がクライアントに送信されます。</p>
<p><code>・InputStream</code> ストリームの内容がクライアントに送信されます。ストリームを使い切ると、ストリームは閉じられます。</p>
<h2 is-upgraded><strong>ミドルウェア</strong></h2>
<p>ミドルウェアとは、ハンドラに追加機能を与える上位の関数です。ミドルウェア関数の第 1 引数にはハンドラを指定し、その戻り値には元のハンドラを呼び出す新しいハンドラ関数を指定します。簡単な例を見てみましょう。</p>
<pre>(defn wrap-content-type [handler content-type]
  (fn [request]
    (let [response (handler request)]
      (assoc-in response [:headers &#34;Content-Type&#34;] content-type))))</pre>
<p>このミドルウェア機能は、ハンドラが生成するすべてのレスポンスに Content-Type ヘッダを追加します。この関数は同期型ハンドラでのみ動作しますが、同期型と非同期型の両方のハンドラをサポートするように拡張することができます。</p>
<pre>(defn content-type-response [response content-type]
  (assoc-in response [:headers &#34;Content-Type&#34;] content-type))

(defn wrap-content-type [handler content-type]
  (fn
    ([request]
      (-&gt; (handler request) (content-type-response content-type)))
    ([request respond raise]
      (handler request #(respond (content-type-response % content-type)) raise))))</pre>
<p>レスポンスを変更する共通のコードを独自の関数に分解したことに注目してください。慣習的に、 <code>wrap-foo</code> がミドルウェアの関数だとすると、<code>foo-request</code> と <code>foo-response</code> はリクエストとレスポンスを操作するヘルパー関数です。</p>
<p>このミドルウェアが書き込まれると、それをハンドラに適用することができます。</p>
<pre>(def app
  (wrap-content-type handler &#34;text/html&#34;))</pre>
<p>これは、ハンドラ <code>handler</code> に <code>wrap-content-type</code> ミドルウェアを適用したもので、新しいハンドラ <code>app</code> を定義しています。</p>
<p>スレッディングマクロ( <code>→</code> )を使うと、ミドルウェアを連鎖させることができます。</p>
<pre>(def app
  (-&gt; handler
      (wrap-content-type &#34;text/html&#34;)
      (wrap-keyword-params)
      (wrap-params)))</pre>
<p>ミドルウェアは Ring で頻繁に使用され、生の HTTP リクエストを処理する以外の機能の多くを提供するために使用されています。パラメータ、セッション、ファイルのアップロードなどは、すべて Ring 標準ライブラリのミドルウェアによって処理されます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="レスポンスの作成" duration="0">
        <p>Ring のレスポンス・マップは手動で作成することもできますが、<code>ring.util.response</code> 名前空間には、この作業を容易にする便利な関数が多数含まれています。</p>
<p>response 関数は、基本的な <code>"200 OK"</code> レスポンスを作成します。</p>
<pre>(response &#34;Hello World&#34;)

; =&gt; {:status 200
    :headers {}
    :body &#34;Hello World&#34;}</pre>
<p>そして、<code>content-type</code> のような関数を使って、ベースとなるレスポンスを変更し、追加のヘッダーや他のコンポーネントを追加することができます。</p>
<pre>(content-type (response &#34;Hello World&#34;) &#34;text/plain&#34;)
 
; =&gt; {:status 200
    :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
    :body &#34;Hello World&#34;}</pre>
<p>また、リダイレクトを行うための特別な機能も存在します。</p>
<pre>(redirect &#34;http://example.com&#34;)
 
; =&gt; {:status 302
    :headers {&#34;Location&#34; &#34;http://example.com&#34;}
    :body &#34;&#34;}</pre>
<p>また、静的なファイルやリソースを返すためには、以下のようにします。</p>
<pre>(file-response &#34;readme.html&#34; {:root &#34;public&#34;})
; =&gt; {:status 200
    :headers {}
    :body (io/file &#34;public/readme.html&#34;)}

(resource-response &#34;readme.html&#34; {:root &#34;public&#34;})
; =&gt; {:status 200
    :headers {}
    :body (io/input-stream (io/resource &#34;public/readme.html&#34;))}</pre>
<p>これらの関数やその他の詳細については、 <a href="https://ring-clojure.github.io/ring/ring.util.response.html" target="_blank">ring.util.response API documentation</a> を参照してください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="静的リソース" duration="0">
        <p>Web アプリケーションでは、画像やスタイルシートなどの静的コンテンツを提供する必要があります。Ring はこれを実現するために 2 つのミドルウェア関数を提供しています。</p>
<p> 1 つは <code>wrap-file</code> です。これは、ローカルファイルシステム上のディレクトリから静的コンテンツを提供します。</p>
<pre>(use &#39;ring.middleware.file)
(def app
  (wrap-file your-handler &#34;/var/www/public&#34;))</pre>
<p>これは、与えられたルートパスのディレクトリに、リクエストに応答するための静的ファイルがあるかどうかをチェックし、そのようなファイルが存在しない場合は、ラップされたハンドラにリクエストをプロキシするようにハンドラをラップします。</p>
<p>もう 1 つは <code>wrap-resource</code> です。これは、JVM のクラスパスから静的コンテンツを提供します。</p>
<pre>(use &#39;ring.middleware.resource)
(def app
  (wrap-resource your-handler &#34;public&#34;))</pre>
<p>Leiningen のような Clojure ビルドツールを使用している場合、プロジェクトのソースファイル以外のリソースは<code>、resources</code> ディレクトリに保存されます。このディレクトリにあるファイルは、自動的に jar ファイルや war ファイルにインクルードされます。</p>
<p>つまり、上記の例では、<code>resources/public</code> ディレクトリに置かれたファイルは、静的ファイルとして提供されます。</p>
<p>多くの場合、<code>wrap-file</code> や <code>wrap-resource</code> を他のミドルウェアと組み合わせたいと思うでしょう。通常は <code>wrap-content-type</code> と <code>wrap-not-modified</code> です。</p>
<pre>(use &#39;ring.middleware.resource
     &#39;ring.middleware.content-type
     &#39;ring.middleware.not-modified)
 
(def app
  (-&gt; your-handler
      (wrap-resource &#34;public&#34;)
      (wrap-content-type)
      (wrap-not-modified))</pre>
<p><code>wrap-content-type</code> ミドルウェアは、ファイルの拡張子に基づいてコンテントタイプを選択します。例えば、hello.txt というファイルのコンテントタイプは text/plain となります。</p>
<p><code>wrap-not-modified</code> ミドルウェアは、レスポンスの <code>Last-Modified</code> ヘッダと、リクエストの <code>If-Modified-Since</code> ヘッダを照合します。これにより、クライアントが既にキャッシュされたリソースをダウンロードする必要がなくなり、帯域幅を節約することができます。</p>
<p>この追加のミドルウェアは、<code>wrap-resource</code> や <code>wrap-file</code> 関数をラップして（つまり、後から）来る必要があることに注意してください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="コンテンツタイプ" duration="0">
        <p><code>wrap-content-type</code> ミドルウェアを使って、URI のファイル拡張子に基づいてContent-Type ヘッダを追加することができます。</p>
<pre>(use &#39;ring.middleware.content-type)
 
(def app
  (wrap-content-type your-handler))</pre>
<p>つまり、ユーザーが以下のスタイルシートにアクセスした場合、</p>
<pre>http://example.com/style/screen.css</pre>
<p><code>content-type</code> ミドルウェアは、次のようなヘッダーを追加します。</p>
<pre>Content-Type: text/css</pre>
<p>デフォルトのコンテンツタイプのマッピングは、 <a href="https://github.com/ring-clojure/ring/blob/master/ring-core/src/ring/util/mime_type.clj" target="_blank">ring-core/src/ring/util/mime_types.clj</a> で見ることができます。</p>
<p>また、<code>:mime-types</code> オプションを使って、カスタムの <code>mime-types</code> を追加することもできます。</p>
<pre>(use &#39;ring.middleware.content-type)
 
(def app
  (wrap-content-type
   your-handler
   {:mime-types {&#34;foo&#34; &#34;text/x-foo&#34;}}))</pre>


      </google-codelab-step>
    
      <google-codelab-step label="パラメータ" duration="0">
        <p>URL エンコードされたパラメータは、ブラウザがウェブアプリケーションに値を渡す主な手段です。ユーザーがフォームを送信する際に送信され、通常はページネーションなどに使用されます。</p>
<p>Ring は低レベルのインターフェースであるため、適切なミドルウェアを適用しない限り、パラメータには対応していません。</p>
<pre>(use &#39;ring.middleware.params)
(def app
  (wrap-params your-handler))</pre>
<p><code>wrap-params</code> ミドルウェアは、URL エンコードされたパラメータを、クエリ文字列または HTTP リクエストボディからサポートします。</p>
<p>ファイルのアップロードはサポートしていません。これはミドルウェアの <code>wrap-multipart-params</code> で処理されます。マルチパートフォームの詳細については、ファイルアップロードのセクションを参照してください。</p>
<p><code>wrap-params</code> 関数はオプションのマップを受け取ります．現在、認識できるキーは 1 つだけです。</p>
<ul>
<li><code>:encoding</code> パラメータの文字エンコーディングを指定します。デフォルトでは、リクエストの 文字エンコーディングが設定されていない場合は、UTF-8 がデフォルトです。 セットされます。</li>
</ul>
<p>パラメータミドルウェアは、ハンドラに適用されると、リクエストマップに 3 つの新しいキーを追加します。</p>
<ul>
<li><code>:query-params</code> クエリ文字列のパラメータのマップ</li>
<li><code>:form-params</code> 送信されたフォームデータに含まれるパラメータのマップ</li>
<li><code>:params</code> すべてのパラメータをマージしたマップ</li>
</ul>
<p>例えば、以下のようなリクエストがあったとします。</p>
<pre>{:request-method :get
 :uri &#34;/search&#34;
 :query-string &#34;q=clojure&#34;}</pre>
<p>すると、 <code>wrap-params</code> ミドルウェアは、リクエストを次のように修正します。</p>
<pre>{:request-method :get
 :uri &#34;/search&#34;
 :query-string &#34;q=clojure&#34;
 :query-params {&#34;q&#34; &#34;clojure&#34;}
 :form-params {}
 :params {&#34;q&#34; &#34;clojure&#34;}}</pre>
<p>通常は、 <code>:params</code> キーのみを使用しますが、他のキーは、クエリ文字列で渡されるパラメータと、POST された HTML フォームで渡されるパラメータを区別する必要がある場合に備えてあります。</p>
<p>パラメータのキーは文字列で、値は、パラメータ名に関連する値が1つしかない場合は文字列、同じ名前の名前と値のペアが複数ある場合はベクターとなります。</p>
<p>例えば、次のような URL があったとします。</p>
<pre>http://example.com/demo?x=hello</pre>
<p>そうすると、パラメータマップは次のようになります。</p>
<pre>{&#34;x&#34; &#34;hello&#34;}</pre>
<p>しかし、同じ名前のパラメータが複数あると</p>
<pre>http://example.com/demo?x=hello&amp;x=world</pre>
<p>そうすると、パラメータマップは次のようになります。</p>
<pre>{&#34;x&#34; [&#34;hello&#34;, &#34;world&#34;]}</pre>


      </google-codelab-step>
    
      <google-codelab-step label="クッキー" duration="0">
        <p>Ring ハンドラにクッキーサポートを追加するには、ミドルウェアの <code>wrap-cookies</code> でラップする必要があります。</p>
<pre>(use &#39;ring.middleware.cookies)
(def app
  (wrap-cookies your-handler))</pre>
<p>これにより、リクエストマップに <code>:cookies</code> キーが追加され、次のようなクッキーのマップが含まれるようになります。</p>
<pre>{&#34;session_id&#34; {:value &#34;session-id-hash&#34;}}</pre>
<p>Cookie を設定するには、<code>:cookie</code> キーをレスポンス・マップに追加します。</p>
<pre>{:status 200
 :headers {}
 :cookies {&#34;session_id&#34; {:value &#34;session-id-hash&#34;}}
 :body &#34;Setting a cookie.&#34;}</pre>
<p>Cookie の値を設定するだけでなく、追加の属性を設定することもできます。</p>
<ul>
<li><code>:domain</code> Cookie を特定のドメインに制限します。</li>
<li><code>:path</code> Cookie を特定のパスに制限します。</li>
<li><code>:secure</code> true の場合、Cookie を HTTPS URL に制限します。</li>
<li><code>:http-only</code> trueの場合、Cookie を HTTP に制限します(例えば JavaScript でアクセスできない)。</li>
<li><code>:max-age</code> Cookie の有効期限が切れるまでの秒数</li>
<li><code>:expires</code> Cookie の有効期限が切れる特定の日時</li>
<li><code>:same-site</code> Cookie をクロスサイト要求で送信するかどうかを決定するために、<code>:strict</code>、<code>:lax</code>、または <code>:none</code> を指定します。</li>
</ul>
<p>1 時間で期限切れになる安全なクッキーが欲しい場合、次のようにします。</p>
<pre>{&#34;secret&#34; {:value &#34;foobar&#34;, :secure true, :max-age 3600}}</pre>


      </google-codelab-step>
    
      <google-codelab-step label="セッション" duration="0">
        <p>Ring のセッションは、可能な限り機能的であることを目指しているため、想像していたものとは少し異なります。</p>
<p>セッションデータは、リクエストマップの <code>:session</code> キーで渡されます。次の例では、セッションから現在のユーザー名を出力しています。</p>
<pre>(use &#39;ring.middleware.session
     &#39;ring.util.response)
 
(defn handler [{session :session}]
  (response (str &#34;Hello &#34; (:username session))))
 
(def app
  (wrap-session handler))</pre>
<p>セッションデータを変更するには、更新されたセッションデータを含む <code>:session</code> キーをレスポンスに追加します。次の例では、現在のセッションがページにアクセスした回数をカウントします。</p>
<pre>(defn handler [{session :session}]
  (let [count   (:count session 0)
        session (assoc session :count (inc count))]
    (-&gt; (response (str &#34;You accessed this page &#34; count &#34; times.&#34;))
        (assoc :session session))))</pre>
<p>セッションを完全に削除するには、レスポンスの <code>:session</code> キーを <code>nil</code> に設定します。</p>
<pre>(defn handler [request]
  (-&gt; (response &#34;Session deleted.&#34;)
      (assoc :session nil)))</pre>
<p>例えば、特権の昇格などにより、単にセッションを再作成したい場合は、セッションのメタデータに <code>:recreate</code> キーを追加します。これにより、ブラウザに送信されるセッション識別子が変更されます。</p>
<pre>(defn handler [request]
  (-&gt; (response &#34;Session identifier recreated&#34;)
      (assoc :session (vary-meta (:session request) assoc :recreate true))))</pre>
<p>セッションクッキーがユーザーのブラウザ上に存在する時間をコントロールしたい場合がよくあります。セッションクッキーの属性を変更するには、<code>:cookie-attrs</code> オプションを使います。</p>
<pre>(def app
  (wrap-session handler {:cookie-attrs {:max-age 3600}}))</pre>
<p>この場合、クッキーの最大寿命は 3600 秒（1 時間）に設定されています。</p>
<p>また、HTTPS で保護されたサイトのセッション・クッキーが HTTP で漏洩しないようにするためにも使用できます。</p>
<pre>(def app
  (wrap-session handler {:cookie-attrs {:secure true}}))</pre>
<h2 is-upgraded><strong>Session Stores</strong></h2>
<p>セッションデータは、セッションストアに保存されます。Ring には2つのストアがあります。</p>
<ul>
<li><code>ring.middleware.session.memory/memory-store</code> メモリ内にセッションを保存します。</li>
<li><code>ring.middleware.session.cookie/cookie-store</code> クッキーで暗号化されたセッションを保存します。</li>
</ul>
<p>デフォルトでは、Ring はセッションデータをメモリ上に保存しますが、<code>:store</code> オプションで上書きすることができます。</p>
<pre>(use &#39;ring.middleware.session.cookie)
 
(def app
  (wrap-session handler {:store (cookie-store {:key &#34;a 16-byte secret&#34;})})</pre>
<p><code>ring.middleware.session.store/SessionStore</code> プロトコルを実装することで、独自のセッションストアを書くことができます。</p>
<pre>(use &#39;ring.middleware.session.store)
 
(deftype CustomStore []
  SessionStore
  (read-session [_ key]
    (read-data key))
  (write-session [_ key data]
    (let [key (or key (generate-new-random-key))]
      (save-data key data)
      key))
  (delete-session [_ key]
    (delete-data key)
    nil))</pre>
<p>セッションの書き込み時に、新しいセッションの場合はキーが <code>nil</code> になることに注意してください。セッションストアはこれを想定して、新しいランダムなキーを生成する必要があります。そうしないと、悪意のあるユーザーが他の人のセッションデータにアクセスできてしまうからです。</p>


      </google-codelab-step>
    
      <google-codelab-step label="ファイルのアップロード" duration="0">
        <p>Web サイトにファイルをアップロードするには、マルチパートのフォームを処理する必要がありますが、Ring は <code>wrap-multipart-params</code> というミドルウェアでこれを提供しています。</p>
<pre>(wrap-multipart-params handler)
(wrap-multipart-params handler options)</pre>
<p>このミドルウェア機能のオプションは</p>
<ul>
<li><code>:encoding</code> パラメータの文字エンコーディングを指定します。<code>wrap-params</code> の同じオプションと同じ働きをします。 オプションと同じ働きをします。</li>
<li><code>:store</code> アップロードされたファイルを保存するために使用する関数です。Ring には、2 つのストア Ring に含まれています。</li>
</ul>
<p>以下は完全な例です。</p>
<pre>(require &#39;[ring.middleware.params :refer [wrap-params]]
         &#39;[ring.middleware.multipart-params :refer [wrap-multipart-params]])
 
(def app
  (-&gt; your-handler
      wrap-params
      wrap-multipart-params))</pre>
<p>アップロードされたファイルは、レスポンスの <code>:multipart-params</code> キーで確認できます。</p>
<p>初期設定ではアップロードは一時ファイルに保存され、アップロードされてから 1 時間後に削除されます。これは<a href="https://ring-clojure.github.io/ring/ring.middleware.multipart-params.temp-file.html" target="_blank"> ring.middleware.multipart-params.temp-file/temp-file-store</a> 関数で処理されます。</p>
<pre>curl -XPOST  &#34;http://localhost:3000&#34; -F file=@words.txt</pre>
<p>これにより、リクエストの <code>:params</code> マップに <code>file</code> キーが追加されます。<code>:tempfile</code> はアップロードされたデータを格納する <code>java.io.File</code> オブジェクトです。これを使って、さらに必要な処理を行うことができます。</p>
<pre>{...
 :params
  {&#34;file&#34; {:filename     &#34;words.txt&#34;
           :content-type &#34;text/plain&#34;
           :tempfile     #object[java.io.File ...]
           :size         51}}
 ...}</pre>
<p>上記の例に基づいて、Ring サーバが作成した一時ファイルをサーバ上の別の場所や恒久的な場所に保存したい場合は、bean を使って <code>tempfile</code> のパス情報を取得し、<code>io/copy</code> と <code>io/file</code> を組み合わせてファイルを読み、新しい場所に保存することができます。</p>
<pre>(def demo-ring-req
  {:params {&#34;file&#34;
            {:filename     &#34;words.txt&#34;}
            :content-type &#34;text/plain&#34;
            :tempfile     #object[java.io.File ...]
            :size         51}})
 
(def save-file [req]
  (let [tmpfilepath (:path (bean (get-in req [:params &#34;file&#34; :tempfile])))
        custom-path &#34;/your/custom/path/file.txt&#34;]
    (do
      (io/copy (io/file tmpfilepath) (io/file custom-path))
      {:status 200
       :headers  {&#34;Content-Type&#34; &#34;text/html&#34;}
       :body (str &#34;File now available for download at: http://localhost:3000/&#34; custom-path)})))
 
(save-file demo-ring-req)</pre>


      </google-codelab-step>
    
      <google-codelab-step label="リローディング" duration="0">
        <p>ソースファイルを編集したときに名前空間を再読み込みすることは、開発に役立つことがあります。 <a href="https://github.com/ring-clojure/ring/tree/master/ring-devel" target="_blank">ring-devel</a> ライブラリは、この目的のためのミドルウェアを提供します。</p>
<pre>(ns myapp
  (:require
   [compojure.core :refer [GET defroutes]]
   [ring.middleware.reload :refer [wrap-reload]]))
 
(defroutes app
  (GET &#34;/&#34; [] &#34;hello world&#34;))
 
(def reloadable-app
  (wrap-reload #&#39;app))</pre>


      </google-codelab-step>
    
      <google-codelab-step label="インタラクティブな開発" duration="0">
        <h2 is-upgraded><strong>コンポーネントのライフサイクル管理</strong></h2>
<p>リロードされたワークフローは、最初に <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded" target="_blank">reloaded workflow</a> で説明しました。</p>
<p>リロードされたワークフローは、起動や停止が可能なコンポーネントを使用し、システムとしてまとめられています。開発中、システムは実行中の REPL で開始されます。ソースファイルが変更された後、システムは停止され、ソースファイルがリロードされ、再びシステムが開始されます。 これを 1 つのコマンドにまとめたり、ショートカットに付けたりすることもできます。</p>
<p>コンポーネントには以下のようなものが含まれます。</p>
<ul>
<li>設定の読み込み</li>
<li>データベース接続</li>
<li>Jetty サーバの実行</li>
</ul>
<p>この方法をサポートしているライブラリの一覧です。</p>
<ul>
<li><a href="https://github.com/stuartsierra/component" target="_blank">https://github.com/stuartsierra/component</a></li>
<li><a href="https://github.com/weavejester/integrant" target="_blank">https://github.com/weavejester/integrant</a></li>
<li><a href="https://github.com/tolitius/mount" target="_blank">https://github.com/tolitius/mount</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="サードパーティ製ライブラリ" duration="0">
        <h2 is-upgraded><strong>アダプタ</strong></h2>
<ul>
<li><a href="https://github.com/http-kit/http-kit" target="_blank">http-kit</a> Ring のためにゼロから書かれました</li>
<li><a href="https://github.com/luminus-framework/ring-undertow-adapter" target="_blank">ring-undertow-adapter</a> Undertow アダプタ</li>
<li><a href="https://github.com/aleph-io/aleph" target="_blank">aleph</a> Netty アダプタ</li>
<li><a href="https://github.com/mmcgrana/ring-httpcore-adapter" target="_blank">ring-httpcore-adapter</a> Apache HttpCore アダプタ</li>
<li><a href="https://github.com/netmelody/ring-simpleweb-adapter" target="_blank">ring-simpleweb-adapter</a> SimpleWeb アダプタ</li>
<li><a href="https://github.com/datskos/ring-netty-adapter" target="_blank">ring-netty-adapter</a> Netty アダプタ</li>
<li><a href="https://github.com/mikejs/ring-mongrel2-adapter" target="_blank">ring-mongrel2-adapter</a> Mongrel2 アダプタ</li>
<li><a href="https://github.com/sprsquish/ring-finagle-adapter" target="_blank">ring-finagle-adapter</a> Finagle アダプタ</li>
</ul>
<h2 is-upgraded><strong>フレームワーク</strong></h2>
<ul>
<li><a href="https://github.com/weavejester/compojure/wiki" target="_blank">Compojure</a> Ring のハンドラ関数を生成するための簡潔な DSL</li>
<li><a href="http://www.luminusweb.net/" target="_blank">Luminus</a> バッテリー同梱のマイクロフレームワーク</li>
<li><a href="https://github.com/cgrand/moustache" target="_blank">Moustache</a> Ring ハンドラやミドルウェアを配線するためのマイクロ DSL</li>
<li><a href="https://github.com/boymaas/clocks" target="_blank">clocks</a> compojure、ring、scripture の上に構築された Clojure の Web DSL</li>
<li><a href="http://www.webnoir.org/" target="_blank">Noir</a> Clojure でウェブサイトを高速に開発するためのマイクロフレームワークですが、lib-noir の採用により非推奨です。</li>
<li><a href="https://github.com/myfreeweb/octohipster" target="_blank">Octohipster</a> Hypermedia と Swagger に対応した REST API フレームワーク</li>
</ul>
<h2 is-upgraded><strong>ミドルウェア</strong></h2>
<ul>
<li><a href="https://github.com/remvee/ring-basic-authentication" target="_blank">ring-basic-authentication</a> 基本認証の実施用ミドルウェア</li>
<li><a href="https://github.com/mmcgrana/ring-json-params" target="_blank">ring-json-params</a> JSON を param にパースするミドルウェア</li>
<li><a href="https://github.com/amalloy/ring-gzip-middleware" target="_blank">ring-gzip-middleware</a> レスポンスボディを gzip するためのミドルウェア</li>
<li><a href="https://github.com/mikejs/ring-etag-middleware" target="_blank">ring-etag-middleware</a> etag の処理と適切な 304 応答の送信を行うミドルウェア</li>
<li><a href="https://github.com/joodie/ring-upload-progress" target="_blank">ring-upload-progress</a> マルチパートアップロードの解析と進捗状況のフィードバックを提供するミドルウェア</li>
<li><a href="https://github.com/alandipert/hoptoad" target="_blank">hoptoad</a> Hoptoad に例外を送信するためのミドルウェア</li>
<li><a href="https://github.com/leadtune/clj-hoptoad" target="_blank">clj-hoptoad</a> Hoptoad に例外を送信するためのもう 1 つのライブラリ</li>
<li><a href="https://github.com/cvillecsteele/permacookie" target="_blank">permacookie</a> 利用者のブラウザに恒久的なクッキーを設定し、利用者を識別するライブラリ</li>
<li><a href="https://github.com/joodie/ring-persistent-cookies" target="_blank">ring-persistent-cookies</a> 有効期限を指定した永続的なクッキーを設定する</li>
<li><a href="https://github.com/hozumi/session-expiry" target="_blank">session-expiry</a> セッションタイムアウトを設定するためのミドルウェア</li>
<li><a href="https://github.com/remvee/ring-partial-content" target="_blank">ring-partial-content</a> コンテンツの部分的なリクエストを処理するためのミドルウェア</li>
<li><a href="https://github.com/ngrunwald/ring-middleware-format" target="_blank">ring-middleware-format</a> パラメータをパースし、JSON などの形式でレスポンスを返すためのミドルウェア</li>
<li><a href="https://github.com/sprsquish/ring-ostrich" target="_blank">ring-ostrich</a> Ostrich 統計データを公開するミドルウェア</li>
<li><a href="https://github.com/edgecase/dieter" target="_blank">dieter</a> Ruby Sprockets にインスパイアされたアセットパイプラインミドルウェア</li>
<li><a href="https://github.com/rapala/ring-request-headers-middleware" target="_blank">ring-request-headers</a> リクエストヘッダを解析する</li>
<li><a href="https://github.com/pjlegato/ring.middleware.logger" target="_blank">ring.middleware.logger</a> Ring を通過したすべてのリクエストを記録する</li>
<li><a href="https://github.com/myfreeweb/ring-ratelimit" target="_blank">ring-ratelimit</a> レート制限</li>
<li><a href="https://github.com/ebaxt/ring-rewrite" target="_blank">ring-rewrite</a> リライトルールの定義と適用</li>
<li><a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a> Ring アプリを作るためのユーティリティとヘルパーのセット</li>
<li><a href="https://github.com/nberger/ring-logger" target="_blank">ring-logger</a> Ring のリクエストとレスポンスをログに記録します。tools.logging や timbre などいずれにも使えます。</li>
<li><a href="https://github.com/patosai/ring-range-middleware" target="_blank">ring-range-middleware</a> HTTP Range リクエストを処理する</li>
</ul>
<h2 is-upgraded><strong>セッション管理</strong></h2>
<ul>
<li><a href="https://github.com/hozumi/mongodb-session" target="_blank">mongodb-session</a> http セッションを mongodb に取り込む</li>
<li><a href="https://github.com/ossareh/ring-session-riak" target="_blank">ring-session-riak</a> riak に保存された Http セッション</li>
<li><a href="https://github.com/paraseba/rrss" target="_blank">rrss</a> Redis セッションストア</li>
<li><a href="https://github.com/killme2008/ring-session-memcached" target="_blank">ring-session-memcached</a> memcached に格納された Http セッション</li>
<li><a href="https://github.com/simlun/enduro-session" target="_blank">enduro-session</a> enduro の file-atom をベースにした耐久性のある Ring セッションストア</li>
<li><a href="https://github.com/yogthos/jdbc-ring-session" target="_blank">jdbc-ring-session</a> JDBC でバックアップされた Ring セッションストア</li>
</ul>
<h2 is-upgraded><strong>Leiningen のプラグイン</strong></h2>
<ul>
<li><a href="https://github.com/weavejester/lein-ring" target="_blank">lein-ring</a> Ring 用 Leiningen プラグイン</li>
</ul>
<h2 is-upgraded><strong>テスト</strong></h2>
<ul>
<li><a href="https://github.com/ring-clojure/ring-mock" target="_blank">ring-mock</a> Ring アプリケーションのテスト用モックリクエストマップの生成</li>
</ul>
<h2 is-upgraded><strong>ユーティリティ</strong></h2>
<ul>
<li><a href="https://github.com/brentonashworth/sandbar/wiki" target="_blank">Sandbar</a> Compojure と Ring のための高次抽象化機能</li>
<li><a href="https://github.com/hiredman/graft" target="_blank">graft</a> URI を Ring 用の関数に変換する</li>
<li><a href="https://github.com/weavejester/clout" target="_blank">Clout</a> Ring リクエストマップの HTTP ルートマッチング</li>
<li><a href="https://github.com/weavejester/ring-serve" target="_blank">ring-serve</a> REPL で開発用 Web サーバを動作させるためのライブラリ</li>
<li><a href="https://github.com/laurentpetit/ring-java-servlet" target="_blank">ring-java-servlet</a> AOTなしで Ring を使用するための汎用サーブレット（web.xml でサーブレットを宣言するのみ）</li>
<li><a href="https://github.com/brehaut/necessary-evil" target="_blank">necessary-evil</a> XML-RPC サーバとクライアントリクエストのためのライブラリ</li>
<li><a href="https://github.com/mattdw/atompub" target="_blank">atompub</a> Weblog の編集などに利用できる Atom シンジケーション（フィード）と Atom Publishing Protocol のためのライブラリ</li>
<li><a href="https://github.com/killme2008/ring.velocity" target="_blank">ring.velocity</a> clojure で ring 用の velocity テンプレートをレンダリングするために設計された Clojure ライブラリ</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ベンチマーク" duration="0">
        <p><a href="https://github.com/ptaoussanis/clojure-web-server-benchmarks" target="_blank">Clojure Web Server Benchmarks</a> を参照してください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="事例" duration="0">
        <p>以下の事例を参照してください。</p>
<ul>
<li><a href="http://gist.github.com/585915" target="_blank">Hello World</a></li>
<li><a href="http://gist.github.com/585921" target="_blank">Hello World with ring.util.response</a></li>
<li><a href="http://gist.github.com/598020" target="_blank">Form parameters</a></li>
<li><a href="http://gist.github.com/608048" target="_blank">Sessions</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="標準ミドルウェア" duration="0">
        <p>Ring 自体に搭載されているミドルウェアをご紹介します。</p>
<p><code>ring/ring-core</code></p>
<ul>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/cookies.clj#L124" target="_blank">wrap-cookies</a> (ring.middleware.cookies)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/file.clj#L14" target="_blank">wrap-file</a> (ring.middleware.file)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/file_info.clj#L89" target="_blank">wrap-file-info</a> (ring.middleware.file-info)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/flash.clj#L4" target="_blank">wrap-flash</a> (ring.middleware.flash)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/keyword_params.clj#L15" target="_blank">wrap-keyword-params</a> (ring.middleware.keyword-params)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/multipart_params.clj#L60" target="_blank">wrap-multipart-params</a> (ring.middleware.multipart-params</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/nested_params.clj#L47" target="_blank">wrap-nested-params</a> (ring.middleware.nested-params</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/params.clj#L54" target="_blank">wrap-params</a> (ring.middleware.params)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/session.clj#L6" target="_blank">wrap-session</a> (ring.middleware.session)</li>
</ul>
<p><code>ring/ring-devel</code></p>
<ul>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/lint.clj#L84" target="_blank">wrap-lint</a> (ring.middleware.lint)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/reload.clj#L4" target="_blank">wrap-reload</a> (ring.middleware.reload)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/stacktrace.clj#L75" target="_blank">wrap-stacktrace</a> (ring.middleware.stacktrace)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="開発のためのセットアップ" duration="0">
        <p>様々なオプションにより、開発ワークフローを最適化できます。</p>
<ul>
<li>ソースファイルの変更時に名前空間をリロードする</li>
<li>lein-ring プラグインによるセットアップ</li>
<li>boot によるセットアップ</li>
<li>モジュール・ライフサイクル・ライブラリを使用する 。</li>
</ul>
<p>1 つ目のアプローチは、高速で簡単にセットアップができます。<a href="https://github.com/ring-clojure/ring/tree/master/ring-devel" target="_blank">ring-devel</a> は、この目的のためにミドルウェアを提供しています。</p>
<p>しかし、名前空間のリロードはアプリケーションの状態をリロードしないという欠点があり、サーバの再起動が必要になる場合があります。</p>
<h2 is-upgraded><strong>lein-ring プラグインによるセットアップ</strong></h2>
<p>lein-ring プラグインが一番わかりやすい方法です。2 つのファイルを作成します。</p>
<ul>
<li><code>src/sample.clj</code></li>
<li><code>project.clj</code></li>
</ul>
<p><code>src/sample.clj</code> は <code>'Hello World'</code> を返すシンプルなサービスです。</p>
<pre>(ns sample)
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world.&#34;})</pre>
<p>プロジェクトファイル <code>project.clj</code> に <code>lein-ring</code> を追加し、Ring のハンドラを設定します。</p>
<pre>:ring {:handler sample/handler}</pre>
<p>次は、最小限の <code>project.clj</code> です。</p>
<pre>(defproject lein-demo &#34;0.1.0-SNAPSHOT&#34;
  :dependencies [[org.clojure/clojure &#34;1.8.0&#34;]
                 [ring/ring-core &#34;1.6.3&#34;]
                 [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                 [ring/ring-devel &#34;1.6.3&#34;]]
  :ring {:handler sample/handler}
  :plugins [[lein-ring &#34;0.12.5&#34;]])</pre>
<p>開発用サーバを起動します。</p>
<pre>​​lein ring server</pre>
<p><a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> のサーバをご覧ください。</p>
<p>サーバは、ソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>
<h2 is-upgraded><strong>Clojure deps と CLI を使ったセットアップ</strong></h2>
<p>Clojure は推移依存性グラフの展開とクラスパスの作成のためのコマンドラインツールを提供します。詳細は <a href="https://clojure.org/guides/deps_and_cli" target="_blank">https://clojure.org/guides/deps_and_cli</a> をご覧ください。</p>
<p>次のようなプロジェクトのファイル構成を作成します。</p>
<pre>.
├── deps.edn
├── dev
│   └── hotreload.clj
└── src
    └── sample
        └── server.clj</pre>
<p>依存関係とクラスパスを記述します。</p>
<p><code>deps.edn</code></p>
<pre>{:paths [&#34;src&#34;]
 :deps
 {org.clojure/clojure {:mvn/version &#34;1.9.0&#34;}
  ring/ring-core {:mvn/version &#34;1.6.3&#34;}
  ring/ring-jetty-adapter {:mvn/version &#34;1.6.3&#34;}}
 :aliases
 {:dev
  {:extra-paths [&#34;dev&#34;]
   :extra-deps {ring/ring-devel {:mvn/version &#34;1.6.3&#34;}}
   :main-opts [&#34;-m&#34; &#34;hotreload&#34;]}}}</pre>
<p>本番サーバを作成します。</p>
<p><code>src/sample/server.clj</code></p>
<pre>(ns sample.server
  (:require [ring.adapter.jetty :refer [run-jetty]])
  (:gen-class))
(defn handler [request]
  {:status  200
   :headers {&#34;Content-Type&#34; &#34;text/plain; charset=UTF-8&#34;}
   :body    &#34;hello world!\n&#34;})
(defn -main [&amp; args]
  (run-jetty handler {:port 3000}))</pre>
<p><code>clojure -M -m sample.server</code> でサーバを起動します。<a href="http://localhost:3000" target="_blank">http://localhost:3000</a> にアクセスし、文字列 <code>"hello world!"</code> が表示されることを確認します。</p>
<p>開発用サーバを作成します。</p>
<p><code>dev/hotreload.clj</code></p>
<pre>(ns hotreload
  (:require [ring.adapter.jetty :refer [run-jetty]]
            [ring.middleware.reload :refer [wrap-reload]]
            [sample.server :refer [handler]])
  (:gen-class))
(def dev-handler
  (wrap-reload #&#39;handler))
(defn -main [&amp; args]
  (run-jetty dev-handler {:port 13000}))</pre>
<p><code>clojure -A:dev -M:dev</code> でサーバを起動します。<a href="http://localhost:13000" target="_blank">http://localhost:13000</a> にアクセスして、文字列 <code>"hello world!"</code> が表示されることを確認してください。 新しい Clojure CLI のバージョンでは、余分な <code>-A:dev</code> の部分は必要ありません。</p>
<p>サーバは、ソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>
<h2 is-upgraded><strong>boot によるセットアップ</strong></h2>
<p>Boot は Clojure のためのビルドツールです。 <a href="https://boot-clj.github.io/" target="_blank">https://boot-clj.github.io/</a></p>
<p>2つのファイルを作成します。</p>
<ul>
<li><code>build.boot</code></li>
<li><code>src/sample.clj</code></li>
</ul>
<p>最小限の <code>build.boot</code> の例です。</p>
<pre>(set-env!
  :resource-paths #{&#34;src&#34;}
  :dependencies &#39;[[org.clojure/clojure &#34;1.8.0&#34;]
                  [ring/ring-core &#34;1.6.3&#34;]
                  [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                  [ring/ring-devel &#34;1.6.3&#34;]])
 
(deftask dev
  &#34;Run server hot reloading Clojure namespaces&#34;
  [p port PORT int &#34;Server port (default 3000)&#34;]
  (require &#39;[sample :as app])
  (apply (resolve &#39;app/run-dev-server) [(or port 3000)]))</pre>
<p>リロードせずに <code>'Hello World'</code> を返すシンプルなサービスです</p>
<p><code>src/sample.clj</code></p>
<pre>(ns sample
  (:require
   [ring.adapter.jetty :refer [run-jetty]]))
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world&#34;})
 
(defn run-dev-server
  [port]
  (run-jetty handler {:port port}))</pre>
<p>boot のタスクを確認して見ましょう。</p>
<pre>boot dev -h</pre>
<p>サーバを起動するには次のようにします。</p>
<pre>boot dev</pre>
<p><a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> をご覧ください。</p>
<p>次に、ホットリロードを追加します。<code>build.boot</code> の <code>dependencies</code> に <code>ring/ring-devel</code> が含まれていることを確認します。ハンドラを <code>wrap-reload</code> ハンドラに指定します。</p>
<pre>(ns sample
  (:require
   [ring.adapter.jetty :refer [run-jetty]]
   [ring.middleware.reload :refer [wrap-reload]]))
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world&#34;})
 
(def dev-handler
  (wrap-reload #&#39;handler))
 
(defn run-dev-server
  [port]
  (run-jetty dev-handler {:port port}))</pre>
<p>サーバを再起動し、 <a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> を開きます。サーバはソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>


      </google-codelab-step>
    
      <google-codelab-step label="プロダクションのためのセットアップ" duration="0">
        <p>lein ring プロジェクトを本番用にセットアップするには、多くのオプションがあります。</p>
<ul>
<li>Tomcat や Jetty のようなサーブレットエンジンへの WAR アーカイブのデプロイ</li>
<li>プラグインである lein-ring や ring-server</li>
<li>組み込み型 Jetty サーバ</li>
<li>モジュールシステムの一部としての組み込み Jetty サーバ</li>
<li>サードパーティー製ライブラリの使用</li>
</ul>
<h2 is-upgraded><strong>WAR アーカイブ</strong></h2>
<p>WAR アーカイブは、既存の Tomcat や Jetty のサーブレットエンジンにアプリケーションをコピーするための標準的なパッケージであり、clojure のコードとすべてのライブラリを含む特定の構造を持つ ZIP ファイルです。</p>
<p>以下のコマンドでアーカイブを作成します。</p>
<pre>lein ring uberwar</pre>
<p>作成したアーカイブをサーブレットエンジンにデプロイします。</p>
<h2 is-upgraded><strong>lein-ring plugin</strong></h2>
<p><code>profile.clj</code> に <a href="https://github.com/weavejester/lein-ring" target="_blank">lein-ring plugin</a> を追加する必要があります。</p>
<pre>:plugins [[lein-ring &#34;0.12.1&#34;]]
:ring {:handler sample/handler}</pre>
<p>環境オプションを使って、ホットリロードとランダムなポート選択を無効にします。</p>
<pre>LEIN_NO_DEV</pre>
<p>サーバを起動します。</p>
<pre>LEIN_NO_DEV=true lein ring server-headless</pre>
<p>詳しい情報は <a href="https://github.com/weavejester/ring-server" target="_blank">https://github.com/weavejester/ring-server</a> をご覧ください。</p>
<h2 is-upgraded><strong>組み込まれた Jetty server</strong></h2>
<p>すでにコンパイルされた Clojure コードとすべてのライブラリを含む JAR ファイルを作成します。</p>
<p>ステップ</p>
<ul>
<li>JAR の <code>src/sample.clj</code> エントリポイント</li>
<li>ビルド構成</li>
</ul>
<p>ハンドラで Jetty を起動するには、<code>ring.adapter.jetty</code>を使用します。</p>
<pre>(ns sample
  (:require [ring.adapter.jetty :refer [run-jetty]])
  (:gen-class))
 
(defn handler [request]
  {:status  200
   :headers {&#34;Content-Type&#34; &#34;text/text&#34;}
   :body    &#34;Hello world&#34;})
 
(defn -main [&amp; args]
  (run-jetty handler {:port (Integer/valueOf (or (System/getenv &#34;port&#34;) &#34;3000&#34;))}))</pre>
<p>AOT のコンパイルでは、<code>:gen-class</code> を使うことが重要です。</p>
<p>次のステップは、ビルドツールに依存します。</p>
<h3 is-upgraded><strong>Leiningenを使ったビルド</strong></h3>
<p><code>project.clj</code> に <code>:aot</code> と <code>:main</code> を追加する必要があります。</p>
<pre>(defproject lein-ring &#34;0.1.0-SNAPSHOT&#34;
  :dependencies [[org.clojure/clojure &#34;1.8.0&#34;]
                 [ring/ring-core &#34;1.6.3&#34;]
                 [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                 [ring/ring-devel &#34;1.6.3&#34;]]
  :profiles{
    :uberjar{
      :aot :all
      :main sample}})</pre>
<h3 is-upgraded><strong>Boot を使ったビルド</strong></h3>
<p>uberjar を作成するタスクを含むシンプルな <code>build.boot</code> です。</p>
<pre>(set-env!
  :resource-paths #{&#34;src&#34;}
  :dependencies &#39;[[org.clojure/clojure &#34;1.8.0&#34;]
                  [ring/ring-core &#34;1.6.3&#34;]
                  [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                  [ring/ring-devel &#34;1.6.3&#34;]])
 
(deftask build
  &#34;Builds an uberjar of this project that can be run with java -jar&#34;
  []
  (comp
   (aot :namespace #{&#39;sample})
   (uber)
   (jar :file &#34;project.jar&#34; :main &#39;sample)
   (sift :include #{#&#34;project.jar&#34;})
   (target)))</pre>
<h3 is-upgraded><strong>サーバの実行</strong></h3>
<p>JAR ファイルを任意のポートで実行します。</p>
<pre>port=2000 java -jar target/project.jar</pre>
<h2 is-upgraded><strong>モジュールシステムの一部としての Jetty サーバの組み込み</strong></h2>
<p>モジュール・ライフサイクル・ライブラリ のページを参照してください。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="./assets/native-shim.js"></script>
  <script src="./assets/custom-elements.min.js"></script>
  <script src="./assets/prettify.js"></script>
  <script src="./assets/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
