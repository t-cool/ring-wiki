
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Ring Wiki</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="ring-wiki"
                  title="Ring Wiki"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="はじめに" duration="0">
        <p>Ring は、プログラミング言語 <a href="http://clojure.org/" target="_blank">Clojure</a> で Web アプリケーションを構築するための低レベルのインターフェースとライブラリです。Ruby の <a href="http://rack.github.io/" target="_blank">Rack</a> や Python の <a href="http://wsgi.readthedocs.org/" target="_blank">WSGI</a>、あるいはJava の Servlet の仕様に似ています。</p>


      </google-codelab-step>
    
      <google-codelab-step label="Ringを使う理由" duration="0">
        <p>WebアプリケーションのベースとしてRingを使用すると、以下のようなメリットがあります。</p>
<ul>
<li>Clojureの関数やマップを使ってアプリケーションを書くことができる</li>
<li>自動リロードされる開発サーバでアプリケーションを実行する</li>
<li>アプリケーションをJavaサーブレットにコンパイルすることができる</li>
<li>アプリケーションをJava warファイルとしてパッケージ化できる</li>
<li>あらかじめ用意されている豊富なミドルウェアを利用できる</li>
<li>作成したアプリケーションを<a href="http://aws.amazon.com/elasticbeanstalk/" target="_blank">Amazon Elastic Beanstalk</a>や<a href="http://heroku.com/" target="_blank">Heroku</a>などのクラウド環境にアプリケーションをデプロイすることができる</li>
</ul>
<p>Ringは、ClojureでWebアプリケーションを書くための、現在のデファクトスタンダードな基盤です。 <a href="http://compojure.org/" target="_blank">Compojure</a>や<a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a>のような高レベルのフレームワークもあります。 <a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a>などの高レベルのフレームワークは、Ringを共通の基盤として使用しています。</p>
<p>Ringは低レベルのインターフェイスしか提供していませんが、高レベルのインターフェイスを使用する予定であっても、Ringの動作を理解しておくと便利です。 Ringの基本的な理解がなければ、ミドルウェアを書くこともできませんし、アプリケーションのデバッグも困難になるでしょう。</p>


      </google-codelab-step>
    
      <google-codelab-step label="コンセプト" duration="0">
        <p>Ring用に開発されたWebアプリケーションは、4つのコンポーネントで構成されています。</p>
<ul>
<li>ハンドラ (Handler)</li>
<li>リクエスト (Request)</li>
<li>レスポンス (Response)</li>
<li>ミドルウェア (Middleware)</li>
</ul>
<h2 is-upgraded><strong>ハンドラ</strong></h2>
<pre>(defn what-is-my-ip [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body (:remote-addr request)})</pre>
<p>この関数は、Ring が HTTP レスポンスに変換できるマップを返します。このレスポンスは、Web アプリケーションへのアクセスに使用された IP アドレスを含むプレーンテキストファイルを返します。</p>
<p>ハンドラは 非同期 の場合もあります。このタイプのハンドラは3つの引数を取ります。 リクエストのマップ、レスポンスのコールバック、例外のコールバックです。</p>
<pre>(defn what-is-my-ip [request respond raise]
  (respond {:status 200
            :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
            :body (:remote-addr request)}))</pre>
<p>この2つのタイプのハンドラはそれぞれ異なるアリティを持っているので、これらを組み合わせて、同期または非同期に使用できるハンドラを作ることができます。</p>
<pre>(defn what-is-my-ip
  ([request]
    {:status 200
     :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
     :body (:remote-addr request)})
  ([request respond raise]
    (respond (what-is-my-ip request))))</pre>
<p>公式のRingミドルウェアは、両方のタイプのハンドラをサポートしていますが、ほとんどの目的では同期ハンドラで十分です。</p>
<p>ハンドラ関数は、次のセクションで説明するさまざまな方法でウェブアプリケーションに変換することができます。</p>
<h2 is-upgraded><strong>リクエスト</strong></h2>
<p>前述のとおり、HTTP リクエストは Clojure のマップで表現されます。常に存在するいくつかの標準的なキーがありますが、リクエストにはミドルウェアによって追加されたカスタムキーが含まれることがあります（そしてしばしばそうなります）。</p>
<p>標準的なキーは次の通りです。</p>
<ul>
<li><code>:server-port</code> リクエストを処理するためのポートです。</li>
<li><code>:server-name</code> 解決されたサーバー名、またはサーバーのIPアドレスです。</li>
<li><code>:remote-addr</code> リクエストを送信したクライアントまたは最後のプロキシのIPアドレスです。</li>
<li><code>:uri</code> リクエストのURI(ドメイン名の後のフルパス)です。</li>
<li><code>:query-string</code> クエリ文字列があれば、それを入力します。</li>
<li><code>:scheme</code> トランスポートプロトコルです。<code>:http</code> または <code>:https</code> のいずれかになります。</li>
<li><code>:request-method</code> HTTPリクエストメソッドで、<code>:get</code>, <code>:head</code>, <code>:options</code>, <code>:put</code>, <code>:post</code>, <code>:delete</code> のいずれかになります。</li>
<li><code>:headers</code> (ヘッダー) 小文字のヘッダ名文字列から対応するヘッダ値文字列へのClojureマップです。</li>
<li><code>:body</code> もしあれば、リクエストボディの入力ストリームです。</li>
</ul>
<p>また、以前のバージョンのRingでは、以下のようなキーがありました。これらは現在 DEPRECATED されています。</p>
<ul>
<li><code>:content-type</code> リクエストボディのMIMEタイプ（分かっている場合）。</li>
<li><code>:Content-Length</code> もしわかっていれば、リクエストボディのバイト数です。</li>
<li><code>:character-encoding</code> もしわかっていれば、リクエストボディで使用されている文字エンコーディングの名前です。</li>
</ul>
<h2 is-upgraded><strong>レスポンス</strong></h2>
<p>レスポンスマップはハンドラーによって作成され、3つのキーが含まれています。</p>
<ul>
<li><code>:status</code> 200、302、404などのHTTPステータスコードです。</li>
<li><code>:headers</code> HTTPヘッダ名からヘッダ値へのClojureマップです。これらの値は文字列で、その場合は HTTP レスポンスで 1 つの名前/値のヘッダが送信されます。また、文字列の集合体で、その場合は各値に対して名前/値のヘッダが送信されます。</li>
<li><code>:body</code> レスポンスのステータスコードに対してレスポンスボディが適切な場合には、レスポンスボディの表現です。ボディは4つのタイプのうちの1つです。</li>
<li><code>String</code> ボディはクライアントに直接送信されます。</li>
<li><code>ISeq</code> seqの各要素は、文字列としてクライアントに送信されます。</li>
<li><code>File</code> 参照されるファイルの内容がクライアントに送信される。</li>
<li><code>InputStream</code> ストリームの内容がクライアントに送信される。ストリームを使い切ると、ストリームは閉じられる。</li>
</ul>
<h2 is-upgraded><strong>ミドルウェア</strong></h2>
<p>ミドルウェアとは、ハンドラーに追加機能を与える上位の関数です。ミドルウェア関数の第一引数にはハンドラを指定し、その戻り値には元のハンドラを呼び出す新しいハンドラ関数を指定します。</p>
<p>簡単な例を挙げてみましょう。</p>
<pre>(defn wrap-content-type [handler content-type]
  (fn [request]
    (let [response (handler request)]
      (assoc-in response [:headers &#34;Content-Type&#34;] content-type))))</pre>
<p>このミドルウェア機能は、ハンドラが生成するすべてのレスポンスに Content-Type ヘッダを追加します。この関数は同期型ハンドラでのみ動作しますが、同期型と非同期型の両方のハンドラをサポートするように拡張することができます。</p>
<pre>(defn content-type-response [response content-type]
  (assoc-in response [:headers &#34;Content-Type&#34;] content-type))

(defn wrap-content-type [handler content-type]
  (fn
    ([request]
      (-&gt; (handler request) (content-type-response content-type)))
    ([request respond raise]
      (handler request #(respond (content-type-response % content-type)) raise))))</pre>
<p>レスポンスを変更する共通のコードを独自の関数に分解したことに注目してください。慣習的に、 <code>wrap-foo</code> がミドルウェアの関数だとすると、<code>foo-request</code> と <code>foo-response</code> はリクエストとレスポンスを操作するヘルパー関数です。</p>
<p>このミドルウェアが書き込まれると、それをハンドラに適用することができます。</p>
<pre>(def app
  (wrap-content-type handler &#34;text/html&#34;))</pre>
<p>これは、ハンドラ <code>handler</code> に <code>wrap-content-type</code> ミドルウェアを適用したもので、新しいハンドラ <code>app</code> を定義しています。</p>
<p>スレッディングマクロ( → )を使うと、ミドルウェアを連鎖させることができます。</p>
<pre>(def app
  (-&gt; handler
      (wrap-content-type &#34;text/html&#34;)
      (wrap-keyword-params)
      (wrap-params)))</pre>
<p>ミドルウェアはRingで頻繁に使用され、生のHTTPリクエストを処理する以外の機能の多くを提供するために使用されています。パラメータ、セッション、ファイルのアップロードなどは、すべてRing標準ライブラリのミドルウェアによって処理されます。</p>


      </google-codelab-step>
    
      <google-codelab-step label="レスポンスの作成" duration="0">
        <p>Ringのレスポンス・マップは手動で作成することもできますが（<a href="https://github.com/t-cool/ring/wiki/Concepts" target="_blank">Concepts</a>を参照）、 [ring.util.response][1] 名前空間には、この作業を容易にする便利な関数が多数含まれています。</p>
<p>response 関数は、基本的な &#34;200 OK&#34; レスポンスを作成します。</p>
<pre>(response &#34;Hello World&#34;)

; =&gt; {:status 200
    :headers {}
    :body &#34;Hello World&#34;}</pre>
<p>そして、<code>content-type</code> のような関数を使って、ベースとなるレスポンスを変更し、追加のヘッダーや他のコンポーネントを追加することができます。</p>
<pre>(content-type (response &#34;Hello World&#34;) &#34;text/plain&#34;)
 
; =&gt; {:status 200
    :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
    :body &#34;Hello World&#34;}</pre>
<p>また、リダイレクトを行うための特別な機能も存在します。</p>
<pre>(redirect &#34;http://example.com&#34;)
 
; =&gt; {:status 302
    :headers {&#34;Location&#34; &#34;http://example.com&#34;}
    :body &#34;&#34;}</pre>
<p>また、静的なファイルやリソースを返すためには、以下のようにします。</p>
<pre>(file-response &#34;readme.html&#34; {:root &#34;public&#34;})
; =&gt; {:status 200
    :headers {}
    :body (io/file &#34;public/readme.html&#34;)}

(resource-response &#34;readme.html&#34; {:root &#34;public&#34;})
; =&gt; {:status 200
    :headers {}
    :body (io/input-stream (io/resource &#34;public/readme.html&#34;))}</pre>
<p>これらの関数やその他の詳細については、 <a href="http://ring-clojure.github.com/ring/ring.util.response.html" target="_blank">ring.util.response API documentation</a> を参照してください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="静的リソース" duration="0">
        <p>Webアプリケーションでは、画像やスタイルシートなどの静的コンテンツを提供する必要があります。Ringはこれを実現するために2つのミドルウェア関数を提供しています。</p>
<p>一つは <code>wrap-file</code> です。これは、ローカルファイルシステム上のディレクトリから静的コンテンツを提供します。</p>
<pre>(use &#39;ring.middleware.file)
(def app
  (wrap-file your-handler &#34;/var/www/public&#34;))</pre>
<p>これは、与えられたルートパスのディレクトリに、リクエストに応答するための静的ファイルがあるかどうかをチェックし、そのようなファイルが存在しない場合は、ラップされたハンドラにリクエストをプロキシするようにハンドラをラップします。</p>
<p>もう一つは <code>wrap-resource</code> です。これは、JVMのクラスパスから静的コンテンツを提供します。</p>
<pre>(use &#39;ring.middleware.resource)
(def app
  (wrap-resource your-handler &#34;public&#34;))</pre>
<p>LeiningenのようなClojureビルドツールを使用している場合、プロジェクトのソースファイル以外のリソースは、resourcesディレクトリに保存されます。このディレクトリにあるファイルは、自動的にjarファイルやwarファイルにインクルードされます。</p>
<p>つまり、上記の例では、<code>resources/public</code> ディレクトリに置かれたファイルは、静的ファイルとして提供されます。</p>
<p>多くの場合、<code>wrap-file</code> や <code>wrap-resource</code> を他のミドルウェアと組み合わせたいと思うでしょう。通常は <code>wrap-content-type</code> と <code>wrap-not-modified</code> です。</p>
<pre>(use &#39;ring.middleware.resource
     &#39;ring.middleware.content-type
     &#39;ring.middleware.not-modified)
 
(def app
  (-&gt; your-handler
      (wrap-resource &#34;public&#34;)
      (wrap-content-type)
      (wrap-not-modified))</pre>
<p>wrap-content-typeミドルウェアは、ファイルの拡張子に基づいてコンテントタイプを選択します。例えば、hello.txtというファイルのコンテントタイプは、text/plainとなります。</p>
<p>wrap-not-modifiedミドルウェアは、レスポンスのLast-Modifiedヘッダと、リクエストのIf-Modified-Sinceヘッダを照合します。これにより、クライアントが既にキャッシュされたリソースをダウンロードする必要がなくなり、帯域幅を節約することができます。</p>
<p>この追加のミドルウェアは、wrap-resourceやwrap-file関数をラップして（つまり、後から）来る必要があることに注意してください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="コンテンツタイプ" duration="0">
        <p>wrap-content-typeミドルウェアを使って、URIのファイル拡張子に基づいてContent-Typeヘッダを追加することができます。</p>
<pre>(use &#39;ring.middleware.content-type)
 
(def app
  (wrap-content-type your-handler))</pre>
<p>つまり、ユーザーが以下のスタイルシートにアクセスした場合、</p>
<pre>http://example.com/style/screen.css</pre>
<p>content-typeミドルウェアは、次のようなヘッダーを追加します。</p>
<pre>Content-Type: text/css</pre>
<p>デフォルトのコンテンツタイプのマッピングは、 <a href="https://github.com/ring-clojure/ring/blob/master/ring-core/src/ring/util/mime_type.clj" target="_blank">ring-core/src/ring/util/mime_types.clj</a> で見ることができます。</p>
<p>また、:mime-typesオプションを使って、カスタムのmime-typesを追加することもできます。</p>
<pre>(use &#39;ring.middleware.content-type)
 
(def app
  (wrap-content-type
   your-handler
   {:mime-types {&#34;foo&#34; &#34;text/x-foo&#34;}}))</pre>


      </google-codelab-step>
    
      <google-codelab-step label="パラメータ" duration="0">
        <p>URLエンコードされたパラメータは、ブラウザがウェブアプリケーションに値を渡す主な手段です。ユーザーがフォームを送信する際に送信され、通常はページネーションなどに使用されます。</p>
<p>Ringは低レベルのインターフェースであるため、適切なミドルウェアを適用しない限り、パラメーターには対応していません。</p>
<pre>(use &#39;ring.middleware.params)
(def app
  (wrap-params your-handler))</pre>
<p>wrap-paramsミドルウェアは、URLエンコードされたパラメータを、クエリ文字列またはHTTPリクエストボディからサポートします。</p>
<p>ファイルのアップロードはサポートしていません。これはミドルウェアの <code>wrap-multipart-params</code> で処理されます。マルチパートフォームの詳細については、ファイルアップロードのセクションを参照してください。</p>
<p><code>wrap-params</code> 関数はオプションのマップを受け取ります．現在、認識できるキーは1つだけです。</p>
<ul>
<li><code>:encoding</code> - パラメータの文字エンコーディングを指定します。デフォルトでは、リクエストの 文字エンコーディングが設定されていない場合は、UTF-8がデフォルトです。 セットされます。</li>
</ul>
<p>パラメーターミドルウェアは、ハンドラーに適用されると、リクエストマップに3つの新しいキーを追加します。</p>
<ul>
<li><code>:query-params</code> - クエリ文字列のパラメータのマップ</li>
<li><code>:form-params</code> - 送信されたフォームデータに含まれるパラメータのマップ</li>
<li><code>:params</code> - すべてのパラメータをマージしたマップ</li>
</ul>
<p>例えば、以下のようなリクエストがあったとします。</p>
<pre>{:request-method :get
 :uri &#34;/search&#34;
 :query-string &#34;q=clojure&#34;}</pre>
<p>すると、 <code>wrap-params</code> ミドルウェアは、リクエストを次のように修正します。</p>
<pre>{:request-method :get
 :uri &#34;/search&#34;
 :query-string &#34;q=clojure&#34;
 :query-params {&#34;q&#34; &#34;clojure&#34;}
 :form-params {}
 :params {&#34;q&#34; &#34;clojure&#34;}}</pre>
<p>通常は、 <code>:params</code> キーのみを使用しますが、他のキーは、クエリ文字列で渡されるパラメータと、POSTされたHTMLフォームで渡されるパラメータを区別する必要がある場合に備えてあります。</p>
<p>パラメータのキーは文字列で、値は、パラメータ名に関連する値が1つしかない場合は文字列、同じ名前の名前と値のペアが複数ある場合はベクターとなります。</p>
<p>例えば、次のようなURLがあったとします。</p>
<pre>http://example.com/demo?x=hello</pre>
<p>そうすると、パラメータマップは次のようになります。</p>
<pre>{&#34;x&#34; &#34;hello&#34;}</pre>
<p>しかし、同じ名前のパラメータが複数あると</p>
<pre>http://example.com/demo?x=hello&amp;x=world</pre>
<p>そうすると、パラメータマップは次のようになります。</p>
<pre>{&#34;x&#34; [&#34;hello&#34;, &#34;world&#34;]}</pre>


      </google-codelab-step>
    
      <google-codelab-step label="クッキー" duration="0">
        <p>Ringハンドラにクッキーサポートを追加するには、ミドルウェアの <code>wrap-cookies</code> でラップする必要があります。</p>
<pre>(use &#39;ring.middleware.cookies)
(def app
  (wrap-cookies your-handler))</pre>
<p>これにより、リクエストマップに <code>:cookies</code> キーが追加され、次のようなクッキーのマップが含まれるようになります。</p>
<pre>{&#34;session_id&#34; {:value &#34;session-id-hash&#34;}}</pre>
<p>Cookieを設定するには、:cookieキーをレスポンス・マップに追加します。</p>
<pre>{:status 200
 :headers {}
 :cookies {&#34;session_id&#34; {:value &#34;session-id-hash&#34;}}
 :body &#34;Setting a cookie.&#34;}</pre>
<p>Cookieの値を設定するだけでなく、追加の属性を設定することもできます。</p>
<ul>
<li><code>:domain</code>-Cookieを特定のドメインに制限します。</li>
<li><code>:path</code>-Cookieを特定のパスに制限します。</li>
<li><code>:secure</code>-trueの場合、CookieをHTTPS URLに制限します。</li>
<li><code>:http-only</code>-trueの場合、CookieをHTTPに制限します(例えばJavaScriptでアクセスできない)。</li>
<li><code>:max-age</code>-Cookieの有効期限が切れるまでの秒数</li>
<li><code>:expires</code>-Cookieの有効期限が切れる特定の日時</li>
<li><code>:same-site</code>-Cookieをクロスサイト要求で送信するかどうかを決定するために、<code>:strict</code>、<code>:lax</code>、または:noneを指定します。</li>
</ul>
<p>ですから、1時間で期限切れになる安全なクッキーが欲しいなら、次のようにします。</p>
<pre>{&#34;secret&#34; {:value &#34;foobar&#34;, :secure true, :max-age 3600}}</pre>


      </google-codelab-step>
    
      <google-codelab-step label="セッション" duration="0">
        <p>Ringのセッションは、可能な限り機能的であることを目指しているため、想像していたものとは少し異なります。</p>
<p>セッションデータは、リクエストマップの <code>:session</code> キーで渡されます。次の例では、セッションから現在のユーザー名を出力しています。</p>
<pre>(use &#39;ring.middleware.session
     &#39;ring.util.response)
 
(defn handler [{session :session}]
  (response (str &#34;Hello &#34; (:username session))))
 
(def app
  (wrap-session handler))</pre>
<p>セッションデータを変更するには、更新されたセッションデータを含む <code>:session</code> キーをレスポンスに追加します。次の例では、現在のセッションがページにアクセスした回数をカウントします。</p>
<pre>(defn handler [{session :session}]
  (let [count   (:count session 0)
        session (assoc session :count (inc count))]
    (-&gt; (response (str &#34;You accessed this page &#34; count &#34; times.&#34;))
        (assoc :session session))))</pre>
<p>セッションを完全に削除するには、レスポンスの <code>:session</code> キーを <code>nil</code> に設定します。</p>
<pre>(defn handler [request]
  (-&gt; (response &#34;Session deleted.&#34;)
      (assoc :session nil)))</pre>
<p>例えば、特権の昇格などにより、単にセッションを再作成したい場合は、セッションのメタデータに <code>:recreate</code> キーを追加します。これにより、ブラウザに送信されるセッション識別子が変更されます。</p>
<pre>(defn handler [request]
  (-&gt; (response &#34;Session identifier recreated&#34;)
      (assoc :session (vary-meta (:session request) assoc :recreate true))))</pre>
<p>セッションクッキーがユーザーのブラウザ上に存在する時間をコントロールしたい場合がよくあります。セッションクッキーの属性を変更するには、:cookie-attrsオプションを使います。</p>
<pre>(def app
  (wrap-session handler {:cookie-attrs {:max-age 3600}}))</pre>
<p>この場合、クッキーの最大寿命は3600秒（1時間）に設定されています。</p>
<p>また、HTTPSで保護されたサイトのセッション・クッキーがHTTPで漏洩しないようにするためにも使用できます。</p>
<pre>(def app
  (wrap-session handler {:cookie-attrs {:secure true}}))</pre>
<h2 is-upgraded><strong>Session Stores</strong></h2>
<p>セッションデータは、セッションストアに保存されます。Ringには2つのストアがあります。</p>
<ul>
<li><code>ring.middleware.session.memory/memory-store</code> - メモリ内にセッションを保存します。</li>
<li><code>ring.middleware.session.cookie/cookie-store</code> - クッキーで暗号化されたセッションを保存します。</li>
</ul>
<p>デフォルトでは、Ringはセッションデータをメモリ上に保存しますが、:storeオプションで上書きすることができます。</p>
<pre>(use &#39;ring.middleware.session.cookie)
 
(def app
  (wrap-session handler {:store (cookie-store {:key &#34;a 16-byte secret&#34;})})</pre>
<p>ring.middleware.session.store/SessionStoreプロトコルを実装することで、独自のセッションストアを書くことができます。</p>
<pre>(use &#39;ring.middleware.session.store)
 
(deftype CustomStore []
  SessionStore
  (read-session [_ key]
    (read-data key))
  (write-session [_ key data]
    (let [key (or key (generate-new-random-key))]
      (save-data key data)
      key))
  (delete-session [_ key]
    (delete-data key)
    nil))</pre>
<p>セッションの書き込み時に、新しいセッションの場合はキーがnilになることに注意してください。セッションストアはこれを想定して、新しいランダムなキーを生成する必要があります。そうしないと、悪意のあるユーザーが他の人のセッションデータにアクセスできてしまうからです。</p>


      </google-codelab-step>
    
      <google-codelab-step label="ファイルのアップロード" duration="0">
        <p>Webサイトにファイルをアップロードするには、マルチパートのフォームを処理する必要がありますが、Ringは <code>wrap-multipart-params</code> というミドルウェアでこれを提供しています。</p>
<pre>(wrap-multipart-params handler)
(wrap-multipart-params handler options)</pre>
<p>このミドルウェア機能のオプションは</p>
<ul>
<li>:encoding(エンコーディング) パラメータの文字エンコーディングを指定します。wrap-params の同じオプションと同じ働きをします。 オプションと同じ働きをします。</li>
<li><code>:store</code> (ストア) アップロードされたファイルを保存するために使用する関数です。Ringには、2つのストア Ringに含まれています。</li>
</ul>
<p>以下は完全な例です。</p>
<pre>(require &#39;[ring.middleware.params :refer [wrap-params]]
         &#39;[ring.middleware.multipart-params :refer [wrap-multipart-params]])
 
(def app
  (-&gt; your-handler
      wrap-params
      wrap-multipart-params))</pre>
<p>アップロードされたファイルは、レスポンスの <code>:multipart-params</code> キーで確認できます。</p>
<p>デフォルトでは、アップロードは一時ファイルに保存され、アップロードされてから1時間後に削除されます。これは <a href="https://github.com/ring-clojure/ring/blob/1.6.3/ring-core/src/ring/middleware/multipart_params/temp_file.clj" target="_blank">ring.middleware.multipart-params.temp-file/temp-file-store</a> 関数で処理されます。</p>
<pre>curl -XPOST  &#34;http://localhost:3000&#34; -F file=@words.txt</pre>
<p>これにより、リクエストの <code>:params</code> マップに <code>file</code> キーが追加されます。<code>:tempfile</code> はアップロードされたデータを格納する <code>java.io.File</code> オブジェクトです。これを使って、さらに必要な処理を行うことができます。</p>
<pre>{...
 :params
  {&#34;file&#34; {:filename     &#34;words.txt&#34;
           :content-type &#34;text/plain&#34;
           :tempfile     #object[java.io.File ...]
           :size         51}}
 ...}</pre>
<p>上記の例に基づいて、Ringサーバが作成したtempfileをサーバ上の別の場所や恒久的な場所に保存したい場合は、beanを使ってtempfileのパス情報を取得し、io/copyとio/fileを組み合わせてファイルを読み、新しい場所に保存することができます。</p>
<pre>(def demo-ring-req
  {:params {&#34;file&#34;
            {:filename     &#34;words.txt&#34;}
            :content-type &#34;text/plain&#34;
            :tempfile     #object[java.io.File ...]
            :size         51}})
 
(def save-file [req]
  (let [tmpfilepath (:path (bean (get-in req [:params &#34;file&#34; :tempfile])))
        custom-path &#34;/your/custom/path/file.txt&#34;]
    (do
      (io/copy (io/file tmpfilepath) (io/file custom-path))
      {:status 200
       :headers  {&#34;Content-Type&#34; &#34;text/html&#34;}
       :body (str &#34;File now available for download at: http://localhost:3000/&#34; custom-path)})))
 
(save-file demo-ring-req)</pre>


      </google-codelab-step>
    
      <google-codelab-step label="リローディング" duration="0">
        <p>ソースファイルを編集したときに名前空間を再読み込みすることは、開発に役立つことがあります。 <a href="https://github.com/ring-clojure/ring/tree/master/ring-devel" target="_blank">ring-devel</a> ライブラリは、この目的のためのミドルウェアを提供します。</p>
<pre>(ns myapp
  (:require
   [compojure.core :refer [GET defroutes]]
   [ring.middleware.reload :refer [wrap-reload]]))
 
(defroutes app
  (GET &#34;/&#34; [] &#34;hello world&#34;))
 
(def reloadable-app
  (wrap-reload #&#39;app))</pre>


      </google-codelab-step>
    
      <google-codelab-step label="インタラクティブな開発" duration="0">
        <h2 is-upgraded><strong>コンポーネントのライフサイクル管理</strong></h2>
<p>リロードされたワークフローは、最初に <a href="http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded" target="_blank">reloaded workflow</a> で説明しました。</p>
<p>リロードされたワークフローは、起動や停止が可能なコンポーネントを使用し、システムとしてまとめられています。開発中、システムは実行中のREPLで開始されます。ソースファイルが変更された後、システムは停止され、ソースファイルがリロードされ、再びシステムが開始されます。 これを一つのコマンドにまとめたり、ショートカットに付けたりすることもできます。</p>
<p>コンポーネントには以下のようなものが含まれます。</p>
<ul>
<li>設定の読み込み</li>
<li>データベース接続</li>
<li>Jettyサーバーの実行</li>
</ul>
<p>この方法をサポートしているライブラリの一覧です。</p>
<ul>
<li><a href="https://github.com/stuartsierra/component" target="_blank">https://github.com/stuartsierra/component</a></li>
<li><a href="https://github.com/weavejester/integrant" target="_blank">https://github.com/weavejester/integrant</a></li>
<li><a href="https://github.com/tolitius/mount" target="_blank">https://github.com/tolitius/mount</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="サードパーティ製のライブラリ" duration="0">
        <h2 is-upgraded><strong>アダプタ</strong></h2>
<ul>
<li><a href="https://github.com/http-kit/http-kit" target="_blank">http-kit</a>: リングのために一から書かれました</li>
<li><a href="https://github.com/luminus-framework/ring-undertow-adapter" target="_blank">ring-undertow-adapter</a>: Undertow アダプタ</li>
<li><a href="https://github.com/aleph-io/aleph" target="_blank">aleph</a>: Netty アダプタ</li>
<li><a href="https://github.com/mmcgrana/ring-httpcore-adapter" target="_blank">ring-httpcore-adapter</a>: Apache HttpCore アダプタ</li>
<li><a href="https://github.com/netmelody/ring-simpleweb-adapter" target="_blank">ring-simpleweb-adapter</a>: SimpleWeb アダプタ</li>
<li><a href="https://github.com/datskos/ring-netty-adapter" target="_blank">ring-netty-adapter</a>: Netty アダプタ</li>
<li><a href="https://github.com/mikejs/ring-mongrel2-adapter" target="_blank">ring-mongrel2-adapter</a>: Mongrel2 アダプタ</li>
<li><a href="https://github.com/sprsquish/ring-finagle-adapter" target="_blank">ring-finagle-adapter</a>: Finagle アダプタ</li>
</ul>
<h2 is-upgraded><strong>フレームワーク</strong></h2>
<ul>
<li><a href="https://github.com/weavejester/compojure/wiki" target="_blank">Compojure</a>: リングハンドラ関数を生成するための簡潔なDSL</li>
<li><a href="http://www.luminusweb.net/" target="_blank">Luminus</a>: バッテリー同梱のマイクロフレームワーク</li>
<li><a href="https://github.com/cgrand/moustache" target="_blank">Moustache</a>: Ringハンドラやミドルウェアを配線するためのマイクロDSL</li>
<li><a href="https://github.com/boymaas/clocks" target="_blank">clocks</a>: compojure、ring、scriptureの上に構築されたClojureのWeb DSL</li>
<li><a href="http://www.webnoir.org/" target="_blank">Noir</a>: Clojure でウェブサイトを高速に開発するためのマイクロフレームワークですが、lib-noir の採用により非推奨です。</li>
<li><a href="https://github.com/myfreeweb/octohipster" target="_blank">Octohipster</a>: HypermediaとSwaggerに対応したREST APIフレームワーク</li>
</ul>
<h2 is-upgraded><strong>ミドルウェア</strong></h2>
<ul>
<li><a href="https://github.com/remvee/ring-basic-authentication" target="_blank">ring-basic-authentication</a>: 基本認証の実施用ミドルウェア</li>
<li><a href="https://github.com/mmcgrana/ring-json-params" target="_blank">ring-json-params</a>: JSONをparamにパースするミドルウェア</li>
<li><a href="https://github.com/amalloy/ring-gzip-middleware" target="_blank">ring-gzip-middleware</a>: レスポンスボディをgzipするためのミドルウェア</li>
<li><a href="https://github.com/mikejs/ring-etag-middleware" target="_blank">ring-etag-middleware</a>: etagの処理と適切な304応答の送信を行うミドルウェア</li>
<li><a href="https://github.com/joodie/ring-upload-progress" target="_blank">ring-upload-progress</a>: マルチパートアップロードの解析と進捗状況のフィードバックを提供するミドルウェア</li>
<li><a href="https://github.com/alandipert/hoptoad" target="_blank">hoptoad</a>: Hoptoadに例外を送信するためのミドルウェア</li>
<li><a href="https://github.com/leadtune/clj-hoptoad" target="_blank">clj-hoptoad</a>: Hoptoad に例外を送信するためのもう一つのライブラリ</li>
<li><a href="https://github.com/cvillecsteele/permacookie" target="_blank">permacookie</a>: 利用者のブラウザに恒久的なクッキーを設定し、利用者を識別するライブラリ</li>
<li><a href="https://github.com/joodie/ring-persistent-cookies" target="_blank">ring-persistent-cookies</a>: 有効期限を指定した永続的なクッキーを設定する</li>
<li><a href="https://github.com/hozumi/session-expiry" target="_blank">session-expiry</a>: セッションタイムアウトを設定するためのミドルウェア</li>
<li><a href="https://github.com/remvee/ring-partial-content" target="_blank">ring-partial-content</a>: コンテンツの部分的なリクエストを処理するためのミドルウェア</li>
<li><a href="https://github.com/ngrunwald/ring-middleware-format" target="_blank">ring-middleware-format</a>: パラメータをパースし、JSONなどの形式でレスポンスを返すためのミドルウェア</li>
<li><a href="https://github.com/sprsquish/ring-ostrich" target="_blank">ring-ostrich</a>: Ostrich 統計データを公開するミドルウェア</li>
<li><a href="https://github.com/edgecase/dieter" target="_blank">dieter</a>: Ruby Sprocketsにインスパイアされたアセットパイプラインミドルウェア</li>
<li><a href="https://github.com/rapala/ring-request-headers-middleware" target="_blank">ring-request-headers</a>: リクエストヘッダを解析する</li>
<li><a href="https://github.com/pjlegato/ring.middleware.logger" target="_blank">ring.middleware.logger</a>: Ringを通過したすべてのリクエストを記録する</li>
<li><a href="https://github.com/myfreeweb/ring-ratelimit" target="_blank">ring-ratelimit</a>: レート制限</li>
<li><a href="https://github.com/ebaxt/ring-rewrite" target="_blank">ring-rewrite</a>: リライトルールの定義と適用</li>
<li><a href="https://github.com/noir-clojure/lib-noir" target="_blank">lib-noir</a>: リングアプリを作るためのユーティリティとヘルパーのセット</li>
<li><a href="https://github.com/nberger/ring-logger" target="_blank">ring-logger</a>: リングのリクエストとレスポンスをログに記録します。tools.loggingやtimbreなどいずれにも使えます。</li>
<li><a href="https://github.com/patosai/ring-range-middleware" target="_blank">ring-range-middleware</a>: HTTP Range リクエストを処理する</li>
</ul>
<h2 is-upgraded><strong>セッション管理</strong></h2>
<ul>
<li><a href="https://github.com/hozumi/mongodb-session" target="_blank">mongodb-session</a>: httpセッションをmongodbに取り込む</li>
<li><a href="https://github.com/ossareh/ring-session-riak" target="_blank">ring-session-riak</a>: riakに保存されたHttpセッション</li>
<li><a href="https://github.com/paraseba/rrss" target="_blank">rrss</a>: Redisセッションストア</li>
<li><a href="https://github.com/killme2008/ring-session-memcached" target="_blank">ring-session-memcached</a>: memcachedに格納されたHttpセッション</li>
<li><a href="https://github.com/simlun/enduro-session" target="_blank">enduro-session</a>: enduroのfile-atomをベースにした耐久性のあるRingセッションストア</li>
<li><a href="https://github.com/yogthos/jdbc-ring-session" target="_blank">jdbc-ring-session</a>: JDBCでバックアップされたRingセッションストア</li>
</ul>
<h2 is-upgraded><strong>Leiningen のプラグイン</strong></h2>
<ul>
<li><a href="https://github.com/weavejester/lein-ring" target="_blank">lein-ring</a>: Leiningenプラグイン（Ring用）</li>
</ul>
<h2 is-upgraded><strong>テスト</strong></h2>
<ul>
<li><a href="https://github.com/ring-clojure/ring-mock" target="_blank">ring-mock</a>: Ringアプリケーションのテスト用モックリクエストマップの生成</li>
</ul>
<h2 is-upgraded><strong>ユーティリティ</strong></h2>
<ul>
<li><a href="https://github.com/brentonashworth/sandbar/wiki" target="_blank">Sandbar</a>: CompojureとRingのための高次抽象化機能</li>
<li><a href="https://github.com/hiredman/graft" target="_blank">graft</a>: URIをRing用の関数に変換する</li>
<li><a href="https://github.com/weavejester/clout" target="_blank">Clout</a>: RingリクエストマップのHTTPルートマッチング</li>
<li><a href="https://github.com/weavejester/ring-serve" target="_blank">ring-serve</a>: REPL で開発用 Web サーバを動作させるためのライブラリ</li>
<li><a href="https://github.com/laurentpetit/ring-java-servlet" target="_blank">ring-java-servlet</a>: AOTなしでリングを使用するための汎用サーブレット（web.xmlでサーブレットを宣言するのみ）</li>
<li><a href="https://github.com/brehaut/necessary-evil" target="_blank">necessary-evil</a>: XML-RPCサーバーとクライアントリクエストのためのライブラリ</li>
<li><a href="https://github.com/mattdw/atompub" target="_blank">atompub</a>: Weblogの編集などに利用できるAtomシンジケーション（フィード）とAtom Publishing Protocolのためのライブラリ</li>
<li><a href="https://github.com/killme2008/ring.velocity" target="_blank">ring.velocity</a>: clojureでring用のvelocityテンプレートをレンダリングするために設計されたClojureライブラリ</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ベンチマーク" duration="0">
        <p><a href="https://github.com/ptaoussanis/clojure-web-server-benchmarks" target="_blank">Clojure Web Server Benchmarks</a> をご参照ください。</p>


      </google-codelab-step>
    
      <google-codelab-step label="事例" duration="0">
        <p>以下の事例をご参照ください。</p>
<ul>
<li><a href="http://gist.github.com/585915" target="_blank">Hello World</a></li>
<li><a href="http://gist.github.com/585921" target="_blank">Hello World with ring.util.response</a></li>
<li><a href="http://gist.github.com/598020" target="_blank">Form parameters</a></li>
<li><a href="http://gist.github.com/608048" target="_blank">Sessions</a></li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="標準ミドルウェア" duration="0">
        <p>Ring自体に搭載されているミドルウェアをご紹介します。</p>
<p>ring/ring-core:</p>
<ul>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/cookies.clj#L124" target="_blank">wrap-cookies</a> (ring.middleware.cookies)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/file.clj#L14" target="_blank">wrap-file</a> (ring.middleware.file)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/file_info.clj#L89" target="_blank">wrap-file-info</a> (ring.middleware.file-info)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/flash.clj#L4" target="_blank">wrap-flash</a> (ring.middleware.flash)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/keyword_params.clj#L15" target="_blank">wrap-keyword-params</a> (ring.middleware.keyword-params)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/multipart_params.clj#L60" target="_blank">wrap-multipart-params</a> (ring.middleware.multipart-params</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/nested_params.clj#L47" target="_blank">wrap-nested-params</a> (ring.middleware.nested-params</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/params.clj#L54" target="_blank">wrap-params</a> (ring.middleware.params)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-core/src/ring/middleware/session.clj#L6" target="_blank">wrap-session</a> (ring.middleware.session)</li>
</ul>
<p>ring/ring-devel:</p>
<ul>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/lint.clj#L84" target="_blank">wrap-lint</a> (ring.middleware.lint)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/reload.clj#L4" target="_blank">wrap-reload</a> (ring.middleware.reload)</li>
<li><a href="https://github.com/mmcgrana/ring/blob/master/ring-devel/src/ring/middleware/stacktrace.clj#L75" target="_blank">wrap-stacktrace</a> (ring.middleware.stacktrace)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="開発のためのセットアップ" duration="0">
        <p>開発ワークフローを最適化するための様々なオプションがあります。</p>
<ul>
<li>ソースファイルの変更時に名前空間をリロードする</li>
<li>lein-ringプラグインによるセットアップ</li>
<li>bootによるセットアップ</li>
<li>モジュール・ライフサイクル・ライブラリを使用する 。</li>
</ul>
<p>第一のアプローチは、高速で、簡単にセットアップができます。<a href="https://github.com/ring-clojure/ring/tree/master/ring-devel" target="_blank">ring-devel</a><a href="https://github.com/ring-clojure/ring/tree/master/ring-devel)%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF%E3%80%81%E3%81%93%E3%81%AE%E7%9B%AE%E7%9A%84%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AB%E3%83%9F%E3%83%89%E3%83%AB%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82" target="_blank">は</a>、この目的のためにミドルウェアを提供しています。</p>
<p>しかし、名前空間のリロードは、アプリケーションの状態をリロードしないという欠点があります。そのため、サーバーの再起動が必要になる場合があります。</p>
<h2 is-upgraded><strong>lein-ringプラグインによるセットアップ</strong></h2>
<p>Lein-Ringプラグインが一番わかりやすい方法です。2つのファイルを作成します。</p>
<ul>
<li>src/sample.clj</li>
<li>project.clj</li>
</ul>
<p>_src/sample.clj_で&#39;Hello World&#39;を返すシンプルなサービスです。</p>
<pre>(ns sample)
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world.&#34;})</pre>
<p>プロジェクトファイル <em>project.clj</em> に <em>lein-ring</em> を追加し、リングハンドラを設定します。</p>
<pre>:ring {:handler sample/handler}</pre>
<p>次は、最小限の <em>project.clj</em> です。</p>
<pre>(defproject lein-demo &#34;0.1.0-SNAPSHOT&#34;
  :dependencies [[org.clojure/clojure &#34;1.8.0&#34;]
                 [ring/ring-core &#34;1.6.3&#34;]
                 [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                 [ring/ring-devel &#34;1.6.3&#34;]]
  :ring {:handler sample/handler}
  :plugins [[lein-ring &#34;0.12.5&#34;]])</pre>
<p>開発用サーバーを起動します。</p>
<pre>​​lein ring server</pre>
<p><a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> のサーバーをご覧ください。</p>
<p>サーバーは、ソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>
<h2 is-upgraded><strong>Clojure depsとCLIを使ったセットアップ</strong></h2>
<p>Clojureは、推移依存性グラフの展開とクラスパスの作成のためのコマンドラインツールを提供します。詳細は <a href="https://clojure.org/guides/deps_and_cli" target="_blank">https://clojure.org/guides/deps_and_cli</a> をご覧ください。</p>
<p>次のようなプロジェクトのファイル構成を作成します。</p>
<pre>.
├── deps.edn
├── dev
│   └── hotreload.clj
└── src
    └── sample
        └── server.clj</pre>
<p>依存関係とクラスパスを記述します。</p>
<pre>;; deps.edn
{:paths [&#34;src&#34;]
 :deps
 {org.clojure/clojure {:mvn/version &#34;1.9.0&#34;}
  ring/ring-core {:mvn/version &#34;1.6.3&#34;}
  ring/ring-jetty-adapter {:mvn/version &#34;1.6.3&#34;}}
 :aliases
 {:dev
  {:extra-paths [&#34;dev&#34;]
   :extra-deps {ring/ring-devel {:mvn/version &#34;1.6.3&#34;}}
   :main-opts [&#34;-m&#34; &#34;hotreload&#34;]}}}</pre>
<p>本番サーバーを作成します。</p>
<pre>;; src/sample/server.clj
(ns sample.server
  (:require [ring.adapter.jetty :refer [run-jetty]])
  (:gen-class))
(defn handler [request]
  {:status  200
   :headers {&#34;Content-Type&#34; &#34;text/plain; charset=UTF-8&#34;}
   :body    &#34;hello world!\n&#34;})
(defn -main [&amp; args]
  (run-jetty handler {:port 3000}))</pre>
<p>clojure -M -m sample.server でサーバを起動します。http://localhost:3000 にアクセスし、文字列 &#34;hello world!&#34; が表示されることを確認します。</p>
<p>開発用サーバーを作成します。</p>
<pre>;; dev/hotreload.clj
(ns hotreload
  (:require [ring.adapter.jetty :refer [run-jetty]]
            [ring.middleware.reload :refer [wrap-reload]]
            [sample.server :refer [handler]])
  (:gen-class))
(def dev-handler
  (wrap-reload #&#39;handler))
(defn -main [&amp; args]
  (run-jetty dev-handler {:port 13000}))</pre>
<p>clojure -A:dev -M:devでサーバーを起動します。http://localhost:13000 にアクセスして、文字列 &#34;hello world!&#34; が表示されることを確認してください。 なお、新しいClojure CLIのバージョンでは、余分な <code>-A:dev</code> の部分は必要ありません。</p>
<p>サーバーは、ソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>
<h2 is-upgraded><strong>bootによるセットアップ</strong></h2>
<p>BootはClojureのためのビルドツールです。 <a href="https://boot-clj.github.io/" target="_blank">https://boot-clj.github.io/</a></p>
<p>2つのファイルを作成します。</p>
<ul>
<li>build.boot</li>
<li>src/sample.clj</li>
</ul>
<p>最小限の build.boot の例です。</p>
<pre>(set-env!
  :resource-paths #{&#34;src&#34;}
  :dependencies &#39;[[org.clojure/clojure &#34;1.8.0&#34;]
                  [ring/ring-core &#34;1.6.3&#34;]
                  [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                  [ring/ring-devel &#34;1.6.3&#34;]])
 
(deftask dev
  &#34;Run server hot reloading Clojure namespaces&#34;
  [p port PORT int &#34;Server port (default 3000)&#34;]
  (require &#39;[sample :as app])
  (apply (resolve &#39;app/run-dev-server) [(or port 3000)]))</pre>
<p>リロードせずに&#39;Hello World&#39;を返すシンプルなサービスです</p>
<p><em>src/sample.clj</em></p>
<pre>(ns sample
  (:require
   [ring.adapter.jetty :refer [run-jetty]]))
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world&#34;})
 
(defn run-dev-server
  [port]
  (run-jetty handler {:port port}))</pre>
<p>boot のタスクを確認して見ましょう。</p>
<pre>boot dev -h</pre>
<p>サーバーを起動するには次のようにします。</p>
<pre>boot dev</pre>
<p><a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> をご覧ください。</p>
<p>次に、ホットリロードを追加します。build.boot_のdependenciesに_ring/ring-devel_が含まれていることを確認します。ハンドラをwrap-reloadハンドラにする。</p>
<pre>(ns sample
  (:require
   [ring.adapter.jetty :refer [run-jetty]]
   [ring.middleware.reload :refer [wrap-reload]]))
 
(defn handler [request]
  {:status 200
   :headers {&#34;Content-Type&#34; &#34;text/plain&#34;}
   :body &#34;Hello world&#34;})
 
(def dev-handler
  (wrap-reload #&#39;handler))
 
(defn run-dev-server
  [port]
  (run-jetty dev-handler {:port port}))</pre>
<p>サーバーを再起動し、 <a href="http://localhost:3000/" target="_blank">http://localhost:3000</a> を開きます。これで、サーバーはソースディレクトリ内の変更されたファイルを自動的に再読み込みします。</p>


      </google-codelab-step>
    
      <google-codelab-step label="プロダクションのためのセットアップ" duration="0">
        <p>lein ringプロジェクトを本番用にセットアップするには、多くのオプションがあります。</p>
<ul>
<li>TomcatやJettyのようなサーブレットエンジンにWAR-archiveをデプロイします。</li>
<li>プラグイン lein-ring と ring-server</li>
<li>組み込み型Jettyサーバ</li>
<li>モジュールシステムの一部としての組み込みJettyサーバ</li>
<li>サードパーティーのライブラリを使用する。</li>
</ul>
<h2 is-upgraded><strong>WAR アーカイブ</strong></h2>
<p>WARアーカイブは、既存のTomcatやJettyのサーブレットエンジンにアプリケーションをコピーするための標準的なパッケージです。</p>
<p>これは、clojureのコードとすべてのライブラリを含む特定の構造を持つZIPファイルです。</p>
<p>以下のコマンドでアーカイブを作成します。</p>
<pre>lein ring uberwar</pre>
<p>作成したアーカイブをサーブレットエンジンにデプロイします。</p>
<h2 is-upgraded><strong>Lein-ring plugin</strong></h2>
<p>_profile.clj_に <a href="https://github.com/weavejester/lein-ring" target="_blank">lein-ring plugin</a> を追加する必要があります。</p>
<pre>:plugins [[lein-ring &#34;0.12.1&#34;]]
:ring {:handler sample/handler}</pre>
<p>さらに、環境オプションを使って、ホットリロードとランダムなポート選択を無効にします。</p>
<pre>LEIN_NO_DEV</pre>
<p>サーバーを起動します。</p>
<pre>LEIN_NO_DEV=true lein ring server-headless</pre>
<p>詳しい情報は <a href="https://github.com/weavejester/ring-server" target="_blank">https://github.com/weavejester/ring-server</a> をご覧ください。</p>
<h2 is-upgraded><strong>組み込まれた Jetty server</strong></h2>
<p>すでにコンパイルされたClojureコードとすべてのライブラリを含むJARファイルを作成します。</p>
<p>ステップ</p>
<ul>
<li>JAR の src/sample.clj エントリポイント</li>
<li>ビルド構成</li>
</ul>
<p>ハンドラでJettyを起動するには、_ring.adapter.jetty_を使用します。</p>
<pre>(ns sample
  (:require [ring.adapter.jetty :refer [run-jetty]])
  (:gen-class))
 
(defn handler [request]
  {:status  200
   :headers {&#34;Content-Type&#34; &#34;text/text&#34;}
   :body    &#34;Hello world&#34;})
 
(defn -main [&amp; args]
  (run-jetty handler {:port (Integer/valueOf (or (System/getenv &#34;port&#34;) &#34;3000&#34;))}))</pre>
<p>AOTのコンパイルでは、*:gen-class*を使うことが重要です。</p>
<p>次のステップは、ビルドツールに依存します。</p>
<h3 is-upgraded><strong>Leiningenを使ったビルド</strong></h3>
<p>project.cljに*:aot*と*:main*を追加する必要があります。</p>
<pre>(defproject lein-ring &#34;0.1.0-SNAPSHOT&#34;
  :dependencies [[org.clojure/clojure &#34;1.8.0&#34;]
                 [ring/ring-core &#34;1.6.3&#34;]
                 [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                 [ring/ring-devel &#34;1.6.3&#34;]]
  :profiles{
    :uberjar{
      :aot :all
      :main sample}})</pre>
<h3 is-upgraded><strong>Bootを使ったビルド</strong></h3>
<p>uberjar を作成するタスクを含むシンプルなbuild.bootです。</p>
<pre>(set-env!
  :resource-paths #{&#34;src&#34;}
  :dependencies &#39;[[org.clojure/clojure &#34;1.8.0&#34;]
                  [ring/ring-core &#34;1.6.3&#34;]
                  [ring/ring-jetty-adapter &#34;1.6.3&#34;]
                  [ring/ring-devel &#34;1.6.3&#34;]])
 
(deftask build
  &#34;Builds an uberjar of this project that can be run with java -jar&#34;
  []
  (comp
   (aot :namespace #{&#39;sample})
   (uber)
   (jar :file &#34;project.jar&#34; :main &#39;sample)
   (sift :include #{#&#34;project.jar&#34;})
   (target)))</pre>
<h3 is-upgraded><strong>サーバの実行</strong></h3>
<p>JARファイルを任意のポートで実行します。</p>
<pre>port=2000 java -jar target/project.jar</pre>
<h2 is-upgraded><strong>モジュールシステムの一部としてのJettyサーバの組み込み</strong></h2>
<p>モジュール・ライフサイクル・ライブラリ のページを見てみましょう。</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
